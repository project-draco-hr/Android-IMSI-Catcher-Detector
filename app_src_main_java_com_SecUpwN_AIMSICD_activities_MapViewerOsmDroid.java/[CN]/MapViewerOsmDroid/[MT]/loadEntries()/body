{
  new AsyncTask<Void,Void,GeoPoint>(){
    @Override protected GeoPoint doInBackground(    Void... voids){
      final int SIGNAL_SIZE_RATIO=15;
      int signal;
      mCellTowerGridMarkerClusterer.getItems().clear();
      loadOpenCellIDMarkers();
      LinkedList<CellTowerMarker> items=new LinkedList<>();
      mDbHelper.open();
      Cursor c=null;
      try {
        c=mDbHelper.getCellData();
      }
 catch (      IllegalStateException ix) {
        Log.e(TAG,ix.getMessage(),ix);
      }
      if (c != null && c.moveToFirst()) {
        do {
          final int cellID=c.getInt(0);
          final int lac=c.getInt(1);
          final int net=c.getInt(2);
          final int mcc=c.getInt(6);
          final int mnc=c.getInt(7);
          final double dlat=Double.parseDouble(c.getString(3));
          final double dlng=Double.parseDouble(c.getString(4));
          if (dlat == 0.0 && dlng == 0.0) {
            continue;
          }
          signal=c.getInt(5);
          if (signal <= 0) {
            signal=20;
          }
          if ((dlat != 0.0) || (dlng != 0.0)) {
            loc=new GeoPoint(dlat,dlng);
            CellTowerMarker ovm=new CellTowerMarker(mContext,mMap,"Cell ID: " + cellID,"",loc,new MarkerData("" + cellID,"" + loc.getLatitude(),"" + loc.getLongitude(),"" + lac,"" + mcc,"" + mnc,"",false));
            ovm.setIcon(getResources().getDrawable(R.drawable.ic_map_pin_blue));
            items.add(ovm);
          }
        }
 while (c.moveToNext());
      }
 else {
        runOnUiThread(new Runnable(){
          @Override public void run(){
            Helpers.msgLong(MapViewerOsmDroid.this,getString(R.string.no_tracked_locations_found));
          }
        }
);
      }
      GeoPoint ret=new GeoPoint(0,0);
      if (mBound) {
        try {
          int mcc=mAimsicdService.getCell().getMCC();
          double[] d=mDbHelper.getDefaultLocation(mcc);
          ret=new GeoPoint(d[0],d[1]);
        }
 catch (        Exception e) {
          Log.e("map","Error getting default location!",e);
        }
      }
      if (c != null) {
        c.close();
      }
      mDbHelper.close();
      while (mAimsicdService == null)       try {
        Thread.sleep(100);
      }
 catch (      Exception e) {
      }
      List<Cell> nc=mAimsicdService.getCellTracker().updateNeighbouringCells();
      for (      Cell cell : nc) {
        try {
          loc=new GeoPoint(cell.getLat(),cell.getLon());
          CellTowerMarker ovm=new CellTowerMarker(mContext,mMap,getString(R.string.cell_id_label) + cell.getCID(),"",loc,new MarkerData("" + cell.getCID(),"" + loc.getLatitude(),"" + loc.getLongitude(),"" + cell.getLAC(),"" + cell.getMCC(),"" + cell.getMNC(),"",false));
          ovm.setIcon(getResources().getDrawable(R.drawable.ic_map_pin_orange));
          items.add(ovm);
        }
 catch (        Exception e) {
          Log.e("map","Error plotting neighbouring cells",e);
        }
      }
      mCellTowerGridMarkerClusterer.addAll(items);
      return ret;
    }
    /** 
 * TODO:  We need a manual way to add our own location in case:
 * a) GPS is jammed or not working
 * b) WiFi location is not used
 * c) Default MCC is too far off
 * @param defaultLoc
 */
    @Override protected void onPostExecute(    GeoPoint defaultLoc){
      if (loc != null && (loc.getLatitude() != 0.0 && loc.getLongitude() != 0.0)) {
        mMap.getController().setZoom(16);
        mMap.getController().animateTo(new GeoPoint(loc.getLatitude(),loc.getLongitude()));
      }
 else {
        if (mBound) {
          GeoLocation lastLoc=mAimsicdService.lastKnownLocation();
          if (lastLoc != null) {
            loc=new GeoPoint(lastLoc.getLatitudeInDegrees(),lastLoc.getLongitudeInDegrees());
            mMap.getController().setZoom(16);
            mMap.getController().animateTo(new GeoPoint(loc.getLatitude(),loc.getLongitude()));
          }
 else {
            loc=defaultLoc;
            mMap.getController().setZoom(12);
            mMap.getController().animateTo(new GeoPoint(loc.getLatitude(),loc.getLongitude()));
          }
        }
      }
      if (mCellTowerGridMarkerClusterer != null) {
        if (BuildConfig.DEBUG && mCellTowerGridMarkerClusterer.getItems() != null) {
          Log.v(TAG,"CellTowerMarkers.invalidate() markers.size():" + mCellTowerGridMarkerClusterer.getItems().size());
        }
        mCellTowerGridMarkerClusterer.invalidate();
      }
    }
  }
.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
